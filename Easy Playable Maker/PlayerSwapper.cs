using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;

namespace Easy_Playable_Maker
{
	public partial class PlayerSwapper : Form
    {

        public PlayerSwapper()
        {
            InitializeComponent();
        }

        private void PlayerSwapper_Load(object sender, EventArgs e)
        {

        }

        private void MakeFile_Click(object sender, EventArgs e)
        {
            string path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop); //It's a step in the right direction however not what I'm looking for specifically
            string pathString = System.IO.Path.Combine(path, "Output");
            System.IO.Directory.CreateDirectory(pathString);

            if (String.IsNullOrEmpty(BkText.Text)) { BkText.Text = "None";}
            if (String.IsNullOrEmpty(HkText.Text)) { HkText.Text = "None"; }
            if (String.IsNullOrEmpty(PlayerText.Text)) { PlayerText.Text = "None"; }
            if (String.IsNullOrEmpty(YawText.Text)) { YawText.Text = "0"; }
            if (String.IsNullOrEmpty(PitchText.Text)) { PitchText.Text = "0"; }
            if (String.IsNullOrEmpty(RollText.Text)) { RollText.Text = "0"; }
            if (String.IsNullOrEmpty(ZText.Text)) { ZText.Text = "0"; }
            if (String.IsNullOrEmpty(YText.Text)) { YText.Text = "0"; }
            if (String.IsNullOrEmpty(XText.Text)) { XText.Text = "0"; }
            if (String.IsNullOrEmpty(FullModelText.Text)) { FullModelText.Text = "None"; }
            if (String.IsNullOrEmpty(IdleText.Text)) { IdleText.Text = "Idle"; }
            if (String.IsNullOrEmpty(PrefixText.Text)) { PrefixText.Text = "Kido"; }
            if (String.IsNullOrEmpty(PlayerNameText.Text)) { PlayerNameText.Text = "PLAYERNAME"; }

            string fileName = PrefixText.Text + "_Player_" + PlayerNameText.Text + "Mod.uc";
            pathString = System.IO.Path.Combine(pathString, fileName);

            if (!System.IO.File.Exists(pathString))
            {
                using (StreamWriter writer = new StreamWriter(pathString))
                {
                    writer.WriteLine("class " + PrefixText.Text + "_Player_" + PlayerNameText.Text + "Mod extends GameMod\n	config(Mods); \n \nevent OnModLoaded() \n{ \n	class'" + PrefixText.Text + "_PlayerSwapper'.static.LoadDefaultPlayers(); \n	HookActorSpawn(class'Hat_Player', 'Hat_Player'); \n	SpawnProps(); \n} \n \nevent OnModUnloaded() \n{ \n	class'" + PrefixText.Text + "_PlayerSwapper'.static.SetToDefault(class'" + PrefixText.Text + "_Player_" + PlayerNameText.Text + "'); \n \n	CleanUpProps(); \n} \n \nfunction SpawnProps() \n{ \n	local float DG; \n \n	if (`GameManager.GetCurrentMapFilename() != `GameManager.HubMapName) return; \n	DG = DegToRad*RadToUnrRot; \n \n	CleanUpProps(); \n \n	// add swappers \n	SpawnProp(class'" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "', " + XText.Text + ", " + YText.Text + ", " + ZText.Text + ", " + RollText.Text + "*DG, " + PitchText.Text + "*DG, " + YawText.Text + "*DG); \n    SpawnProp(class'" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo', " + XText.Text + ", " + YText.Text + ", " + ZText.Text + ", " + RollText.Text + "*DG, " + PitchText.Text + "*DG, " + YawText.Text + "*DG); \n	SpawnProp(class'" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo2', " + XText.Text + ", " + YText.Text + ", " + ZText.Text + ", " + RollText.Text + "*DG, " + PitchText.Text + "*DG, " + YawText.Text + "*DG); \n \n} \n \nfunction CleanUpProps() \n{ \n	local " + PrefixText.Text + "_PlayerSwapper swapper; \n \n	foreach class'WorldInfo'.static.GetWorldInfo().DynamicActors(class'" + PrefixText.Text + "_PlayerSwapper', swapper) \n	{ \n		if (swapper.class.Name == '" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "') swapper.Destroy(); \n		if (swapper.class.Name == '" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo') swapper.Destroy(); \n		if (swapper.class.Name == '" + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo2') swapper.Destroy(); \n	} \n \n \n} \n \n \n \nfunction Actor SpawnPropAtOffset(class<Actor> C, Vector Offset, float OffYaw, float X, float Y, float Z, float Roll, float Pitch, float Yaw, optional StaticMesh Mesh, optional float S = 1) \n{ \n	local Vector v; \n	local Rotator r; \n \n	v.X = X; \n	v.Y = Y; \n	v.Z = Z; \n \n	r.Yaw = -OffYaw; \n	v = (v << r) + Offset; \n	Yaw -= r.Yaw; \n \n	return SpawnProp(C, v.X, v.Y, v.Z, Roll, Pitch, Yaw, Mesh, S); \n} \n \nfunction Actor SpawnProp(class<Actor> C, float X, float Y, float Z, float Roll, float Pitch, float Yaw, optional StaticMesh Mesh, optional float S = 1) \n{ \n	local Actor act; \n	local Vector vt; \n	local Rotator rt; \n \n	vt.X = X; \n	vt.Y = Y; \n	vt.Z = Z; \n	rt.Roll = Roll; \n	rt.Pitch = Pitch; \n	rt.Yaw = Yaw; \n \n	act = Spawn(C,self,,vt,rt); \n \n	return act; \n}");
                }
            }

            pathString = System.IO.Path.Combine(path, "Output");
            fileName = PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo.uc";
            pathString = System.IO.Path.Combine(pathString, fileName);

            if (!System.IO.File.Exists(pathString))
            {
                using (StreamWriter writer = new StreamWriter(pathString))
                {
                    writer.WriteLine("class " + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo extends " + PrefixText.Text + "_PlayerSwapper\n	placeable; \n \nvar SkeletalMeshComponent KidHat; \n \ndefaultproperties \n{ \n	Begin Object Name=SkeletalMeshComponent0 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidHead' \n		PhysicsAsset=PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidHead_Physics' \n		AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n		AnimSets(3)=AnimSet'HatInTime_Characters_HatKid3.AnimSet.HatKidV2_Metro' \n		CastShadow=false \n	End Object \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent1 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidBody' \n		PhysicsAsset=PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidBody_Physics' \n        AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n		AnimSets(3)=AnimSet'HatInTime_Characters_HatKid3.AnimSet.HatKidV2_Metro' \n		ParentAnimComponent=SkeletalMeshComponent0 \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Cosmetics(0) = SkeletalMeshComponent1 \n	Components.Add(SkeletalMeshComponent1) \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent2 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidLegs' \n		PhysicsAsset=PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidLegs_Physics' \n        AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n		AnimSets(3)=AnimSet'HatInTime_Characters_HatKid3.AnimSet.HatKidV2_Metro' \n		ParentAnimComponent=SkeletalMeshComponent0 \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Cosmetics(1) = SkeletalMeshComponent2 \n	Components.Add(SkeletalMeshComponent2) \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent3 \n		SkeletalMesh=SkeletalMesh'HatInTime_Costumes.models.hat_kid_hat' \n		PhysicsAsset=PhysicsAsset'HatInTime_Costumes.Physics.hat_kid_hat_Physics' \n \n		Materials(1)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(2)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(3)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(4)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(5)=Material'HatInTime_Characters.Materials.Invisible' \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Components.Add(SkeletalMeshComponent3) \n	KidHat = SkeletalMeshComponent3 \n \n	Begin Object Class=Hat_ExpressionComponent_HatKid Name=hExpression \n	End Object \n	Components.Add(hExpression) \n	Expression = hExpression \n \n	UndoForPlayer = 1 \n	UndoClass = class'" + PrefixText.Text + "_Player_" + PlayerNameText.Text + "' \n	ConversationTree = " + HkText.Text + " \n	LookAtPlayerWhenTalking = false \n \n	Anim = \"" + IdleText.Text + "\" \n \n} \n \nsimulated event PostBeginPlay() \n{ \n			//Hat_PlayerController(GetALocalPlayerController()).GetLoadout().RemoveBackpack(class'Hat_Loadout'.static.MakeLoadoutItem(class'Grork_Weapon_Knife')); \n \n	if (KidHat != None) \n		SkeletalMeshComponent.AttachComponentToSocket(KidHat, 'KidHat'); \n \n	Super.PostBeginPlay(); \n}");
                }
            }

            pathString = System.IO.Path.Combine(path, "Output");
            fileName = PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo2.uc";
            pathString = System.IO.Path.Combine(pathString, fileName);

            if (!System.IO.File.Exists(pathString))
            {
                using (StreamWriter writer = new StreamWriter(pathString))
                {
                    writer.WriteLine("class " + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + "_Undo2 extends " + PrefixText.Text + "_PlayerSwapper \n	placeable; \n \nvar SkeletalMeshComponent KidHat; \n \ndefaultproperties \n{ \n	Begin Object Name=SkeletalMeshComponent0 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_Coop.models.bowkid_head_skm' \n		bHasPhysicsAssetInstance=false \n        AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n		AnimSets(3)=AnimSet'HatInTime_Characters_HatKid3.AnimSet.HatKidV2_Metro' \n		CastShadow=false \n \n		Materials(4)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(6)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(7)=Material'HatInTime_Characters.Materials.Invisible' \n		Materials(8)=Material'HatInTime_Characters.Materials.Invisible' \n	End Object \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent1 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_Coop.models.bowkid_body_skm' \n		PhysicsAsset=PhysicsAsset'HatInTime_Characters_Coop.Physics.bowkid_body_skm_Physics' \n		ParentAnimComponent=SkeletalMeshComponent0 \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Cosmetics(0) = SkeletalMeshComponent1 \n	Components.Add(SkeletalMeshComponent1) \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent2 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_Coop.models.bowkid_legs_skm' \n		ParentAnimComponent=SkeletalMeshComponent0 \n \n		bHasPhysicsAssetInstance=false \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Cosmetics(1) = SkeletalMeshComponent2 \n	Components.Add(SkeletalMeshComponent2) \n \n	Begin Object Class=SkeletalMeshComponent Name=SkeletalMeshComponent3 \n		SkeletalMesh=SkeletalMesh'HatInTime_Characters_Coop.models.bowkid_bow_skm' \n		PhysicsAsset=PhysicsAsset'HatInTime_Characters_Coop.Physics.bowkid_bow_skm_Physics' \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		//CastShadow=true \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=false \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=true \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bPerBoneMotionBlur=true \n		bAcceptsDecals=false \n		bAcceptsDynamicDecals=false \n	End Object \n	Components.Add(SkeletalMeshComponent3) \n	KidHat = SkeletalMeshComponent3 \n \n	Begin Object Class=Hat_ExpressionComponent_BowKid Name=hExpression \n	End Object \n	Components.Add(hExpression) \n	Expression = hExpression \n \n	UndoForPlayer = 2 \n	UndoClass = class'" + PrefixText.Text + "_Player_" + PlayerNameText.Text + "' \n	ConversationTree = " + BkText.Text + " \n	LookAtPlayerWhenTalking = false \n \n	Anim = \"" + IdleText.Text + "\" \n \n} \n \nsimulated event PostBeginPlay() \n{ \n	if (KidHat != None) \n		SkeletalMeshComponent.AttachComponentToSocket(KidHat, 'Bow'); \n \n	Super.PostBeginPlay(); \n}");
                }
            }

            pathString = System.IO.Path.Combine(path, "Output");
            fileName = PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + ".uc";
            pathString = System.IO.Path.Combine(pathString, fileName);

            if (!System.IO.File.Exists(pathString))
            {
                using (StreamWriter writer = new StreamWriter(pathString))
                {
                    writer.WriteLine("class " + PrefixText.Text + "_PlayerSwapper_" + PlayerNameText.Text + " extends " + PrefixText.Text + "_PlayerSwapper \n	placeable; \n \ndefaultproperties \n{ \n    Begin Object Name=SkeletalMeshComponent0 \n        SkeletalMesh=" + FullModelText.Text + " \n        AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n		AnimSets(3)=AnimSet'HatInTime_Characters_HatKid3.AnimSet.HatKidV2_Metro' \n        CastShadow=false \n    End Object \n \n    PlayerClass = class'" + PrefixText.Text + "_Player_" + PlayerNameText.Text + "' \n    ConversationTree = " + PlayerText.Text + " \n    LookAtPlayerWhenTalking = false \n \n	Anim = \"" + IdleText.Text + "\" \n \n \n}");
                }
            }

            pathString = System.IO.Path.Combine(path, "Output");
            fileName = PrefixText.Text + "_PlayerSwapper.uc";
            pathString = System.IO.Path.Combine(pathString, fileName);

            if (!System.IO.File.Exists(pathString))
            {
                using (StreamWriter writer = new StreamWriter(pathString))
                {
                    writer.WriteLine("class " + PrefixText.Text + "_PlayerSwapper extends Hat_NPC \n	notplaceable \n	abstract; \n \nconst PlayerSwapKey = \"PlayerSwap\"; \n \nvar Array<SkeletalMeshComponent> Cosmetics; \nvar class<Pawn> PlayerClass; \nvar() Name Anim; \nvar Vector HubLocation; \nvar Rotator HubRotation; \n \nvar class<Pawn> UndoClass; \nvar int UndoForPlayer; \nvar transient int HasBowKidMod; \n \nvar Array<Actor> Props; \n \nsimulated event PostBeginPlay() \n{ \n	if (UndoForPlayer == 1) \n		PlayerClass = class'Hat_Game'.default.DefaultPawnClass; \n	/*if (UndoForPlayer == 2) \n		PlayerClass = `GameManager.default.DefaultCoopPawnClass;*/ \n \n	if (`GameManager.GetCurrentMapFilename() == `GameManager.HubMapName) \n	{ \n		if (Location == vect(0,0,0) && HubLocation != vect(0,0,0)) \n			SetLocation(HubLocation); \n		if (Rotation == rot(0,0,0) && HubRotation != rot(0,0,0)) \n			SetRotation(HubRotation); \n	} \n \n	if (Anim != '') \n		PlayAnimation(Anim, true); \n \n	Super.PostBeginPlay(); \n} \n \nsimulated event Tick(float d) \n{ \n	local int i; \n	Super.Tick(d); \n	SetHidden(!ShouldShow()); \n \n	if (Props.Length > 0) \n		for (i = 0; i < Props.Length; i++) \n			Props[i].SetHidden(!ShouldShow()); \n} \n \nfunction bool ShouldShow() \n{ \n	local Array<Player> GamePlayers; \n	local bool r; \n	local int i; \n \n	GamePlayers = class'Engine'.static.GetEngine().GamePlayers; \n \n	for (i = 0; i < GamePlayers.Length; i++) \n	{ \n		if (GamePlayers[i].Actor != None && GamePlayers[i].Actor.Pawn != None) \n		{ \n			// if this character is in play, they're not available to switch to \n			if (GamePlayers[i].Actor.Pawn.Class == PlayerClass) \n				return false; \n			// the character this undoes is in play \n			if (GamePlayers[i].Actor.Pawn.Class == UndoClass) \n				r = true; \n		} \n	} \n \n	if (UndoForPlayer > 0) \n	{ \n		if (UndoForPlayer == 2) \n		{ \n			// not in coop, so there's no player 2 to undo for \n			if (GamePlayers.Length <= 1) \n				return false; \n \n			// if playable bowkid is installed, bowkid will sit over where playable bowkid sits and no bowkid undos are ever shown \n			if (HasPlayableBowkid() && `GameManager.GetCurrentMapFilename() == `GameManager.HubMapName) \n				return false; \n		} \n \n		// the character this undoes isn't in play, they're sitting here, so hide \n		if (!r) return false; \n \n		// if playable bowkid isn't installed, there's only ever one hatkid swapper left by elimination \n		if (!HasPlayableBowkid() || `GameManager.GetCurrentMapFilename() != `GameManager.HubMapName) \n			return true; \n \n		// this is the undo for the player that is using the character (and this undo character isn't in play) \n		return UndoForPlayer > 0 && GamePlayers[UndoForPlayer-1].Actor.Pawn.Class == UndoClass; \n	} \n \n	return true; \n} \n \nfunction bool HasPlayableBowkid() \n{ \n	local Array<GameModInfo> ModList; \n	local int i; \n \n	if (HasBowKidMod != 0) \n		return HasBowKidMod > 1; \n \n	HasBowKidMod = 1; \n \n	ModList = class'GameMod'.static.GetModList(); \n	for (i = 0; i < ModList.Length; i++) \n		if (ModList[i].ModClass != None && ModList[i].ModClass.Name == 'ArgMod_Player_BowKid') \n			HasBowKidMod = 2; \n \n	return HasBowKidMod > 1; \n} \n \nsimulated function bool OnInteractedWith(Actor a) \n{ \n	if (ConversationTree == None) return false; \n	Hat_PlayerController(Pawn(a).Controller).TalkManager.PushConversationWithSpeaker(ConversationTree, self); \n	Hat_PlayerController(Pawn(a).Controller).TalkManager.PushCompleteDelegate(self.OnTalkMessageComplete); \n	return true; \n} \n \ndelegate OnTalkMessageComplete(Controller c, int answer) \n{ \n	if (answer == 0) PlayerSwap(PlayerClass, c); \n} \n \nsimulated function bool CanBeInteractedWith(Actor a) \n{ \n	// only allow mixing up undos if playable bowkid is installed, since that mod includes all the content/fixes for bowkid as player 1. \n	if (UndoForPlayer > 0 && !HasPlayableBowkid() && Hat_Player(a) != None && Hat_Player(a).Controller != None) \n		if (class'Engine'.static.GetEngine().GamePlayers.Length >= UndoForPlayer && class'Engine'.static.GetEngine().GamePlayers[UndoForPlayer-1].Actor != Hat_Player(a).Controller) \n			return false; \n \n	return Super.CanBeInteractedWith(a); \n} \n \nstatic function PlayerSwap(class<Pawn> PawnClass, Controller pc, optional bool force = false, optional bool silent = false) \n{ \n	local Pawn NewPawn; \n	local Rotator SavedRot; \n \n	if (class'Engine'.static.GetEngine().GamePlayers.Length > 1 && class'Engine'.static.GetEngine().GamePlayers[1].Actor == pc) \n		SaveDefaultPlayer(1, PawnClass); \n	else \n		SaveDefaultPlayer(0, PawnClass); \n \n	if (pc.Pawn.Class == PawnClass && !force) return; \n	if (pc.Pawn == None) return; \n \n	SavedRot = pc.Rotation; \n	NewPawn = pc.Spawn(PawnClass,,,pc.Pawn.Location,pc.Pawn.Rotation,,true); \n	NewPawn.Health = pc.Pawn.Health; \n	if (pc.Pawn.bHidden) NewPawn.SetHidden(true); \n	pc.Pawn.Destroy(); \n	pc.Pawn = None; \n	pc.Possess(NewPawn, false); \n	pc.SetRotation(SavedRot); \n \n	FixLoadout(pc, true); \n \n	if (!silent) \n	{ \n		class'WorldInfo'.static.GetWorldInfo().MyEmitterPool.SpawnEmitter(ParticleSystem'HatInTime_PlayerAssets.Particles.PlayerActions.FormTransform', pc.Pawn.Location); \n		pc.Pawn.PlaySound(SoundCue'HatinTime_SFX_Spaceship.Deco_TimeRiftSpawn_cue'); \n	} \n} \n \nstatic function FixLoadout(Controller pc, optional bool ForceDefaultHat) \n{ \n	local Hat_Loadout l; \n	local int i; \n	local BackpackInfo2017 bp; \n \n	`SaveManager.LoadPlayerLoadouts(); \n	if (Hat_Player(pc.Pawn) != None) \n		Hat_Player(pc.Pawn).AddDefaultInventory(); \n \n	if (Hat_PlayerReplicationInfo(pc.Pawn.PlayerReplicationInfo) != None) \n		l = Hat_PlayerReplicationInfo(pc.Pawn.PlayerReplicationInfo).MyLoadout; \n	if (l == None && Hat_PlayerController(pc) != None) \n		l = Hat_PlayerController(pc).GetLoadout(); \n \n	if (Hat_Player(pc.Pawn) == None || l == None) return; \n \n	if (ForceDefaultHat) \n	{ \n		if (Hat_Player(pc.Pawn).CanWearBowKidCosmetics && !Hat_Player(pc.Pawn).CanWearHatKidCosmetics) \n		{ \n			bp = l.GetSaveGame() != None ? l.GetSaveGame().MyBackpack2017 : `GRI.MyBackpack2017; \n			i = l.BackpackHasHat(l.MakeLoadoutItem(class'Hat_Ability_Help', class'Hat_CosmeticItemQualityInfo_Help_Bow'), false); \n			if (i != INDEX_NONE) l.EquipLoadout(bp.Hats[i]); \n		} \n		else \n		{ \n			l.EquipDefaultHat(); \n		} \n	} \n \n	`SaveManager.StorePlayerLoadouts(); \n} \n \nstatic function SetToDefault(class<Pawn> PawnClass) \n{ \n	if (class'WorldInfo'.static.GetWorldInfo().Game.DefaultPawnClass == PawnClass) \n	{ \n		if (class'Engine'.static.GetEngine().GamePlayers.Length > 0 && class'Engine'.static.GetEngine().GamePlayers[0].Actor != None) \n			PlayerSwap(class'Hat_Game'.default.DefaultPawnClass, class'Engine'.static.GetEngine().GamePlayers[0].Actor,,true); \n		WipeDefaultPlayer(0); \n	} \n \n	/*if (`GameManager.DefaultCoopPawnClass == PawnClass) \n	{ \n		if (class'Engine'.static.GetEngine().GamePlayers.Length > 1 && class'Engine'.static.GetEngine().GamePlayers[1].Actor != None) \n			PlayerSwap(`GameManager.default.DefaultCoopPawnClass, class'Engine'.static.GetEngine().GamePlayers[1].Actor,,true); \n		WipeDefaultPlayer(1); \n	}*/ \n} \n \nstatic function SaveDefaultPlayer(int pid, class<Pawn> PawnClass) \n{ \n	if (SavingDisabled()) return; \n	WipeDefaultPlayer(pid); \n	class'Hat_SaveBitHelper'.static.SetLevelBits(locs(\"player\"$pid$\"+\"$PawnClass.Name), 1, PlayerSwapKey); \n} \n \nstatic function LoadDefaultPlayers() \n{ \n	LoadDefaultPlayer(0); \n	LoadDefaultPlayer(1); \n} \n \nstatic function DisableForAct() \n{ \n	class'Hat_SaveBitHelper'.static.SetActBits(\"ArgPlayerSwapperSaveDisabled\", 1); \n} \n \nstatic function bool SavingDisabled() \n{ \n	return class'Hat_SaveBitHelper'.static.GetActBits(\"ArgPlayerSwapperSaveDisabled\") > 0; \n} \n \nstatic function LoadDefaultPlayer(int pid) \n{ \n	local Hat_SaveGame_Base s; \n	local int i,ii; \n	local class<Pawn> PawnClass; \n	local Array<String> arr; \n \n	if (SavingDisabled()) return; \n \n	s = class'Hat_SaveBitHelper'.static.GetSaveGame(); \n	if (s == None) return; \n \n	i = s.GetLevelSaveInfoIndex(class'Hat_SaveBitHelper'.static.GetCorrectedMapFilename(PlayerSwapKey), true); \n	if (i < 0) return; \n \n	for (ii = 0; ii < s.LevelSaveInfo[i].LevelBits.Length; ii++) \n	{ \n		arr = SplitString(s.LevelSaveInfo[i].LevelBits[ii].Id, \"+\", true); \n		if (arr[0] ~= (\"player\"$pid) && s.LevelSaveInfo[i].LevelBits[ii].Bits > 0) \n		{ \n			PawnClass = class<Pawn>(class'Hat_ClassHelper'.static.GetScriptClass(arr[1])); \n			if (PawnClass == None) return;// there's an active swap, but it's from a different player mod, so do nothing \n			if (pid == 0) class'WorldInfo'.static.GetWorldInfo().Game.DefaultPawnClass = PawnClass; \n			/*else `GameManager.DefaultCoopPawnClass = PawnClass;*/ \n			return; \n		} \n	} \n \n	// found no active swaps, so just wipe everything \n	if (pid == 0) class'WorldInfo'.static.GetWorldInfo().Game.DefaultPawnClass = class'Hat_Game'.default.DefaultPawnClass; \n	/*else `GameManager.DefaultCoopPawnClass = `GameManager.default.DefaultCoopPawnClass;*/ \n	WipeDefaultPlayer(pid); \n} \n \nstatic function WipeDefaultPlayer(int pid) \n{ \n	local Hat_SaveGame_Base s; \n	local int i,ii; \n	local Array<String> arr; \n \n	if (SavingDisabled()) return; \n \n	s = class'Hat_SaveBitHelper'.static.GetSaveGame(); \n	if (s == None) return; \n \n	i = s.GetLevelSaveInfoIndex(class'Hat_SaveBitHelper'.static.GetCorrectedMapFilename(PlayerSwapKey), true); \n	if (i < 0) return; \n \n	for (ii = 0; ii < s.LevelSaveInfo[i].LevelBits.Length; ii++) \n	{ \n		arr = SplitString(s.LevelSaveInfo[i].LevelBits[ii].Id, \"+\", true); \n		if (arr[0] ~= (\"player\"$pid)) \n			s.LevelSaveInfo[i].LevelBits[ii].Bits = 0; \n	} \n} \n \ndefaultproperties \n{ \n	Begin Object Name=MyLightEnvironment \n		bSynthesizeSHLight=true \n		bIsCharacterLightEnvironment=true \n		bUseBooleanEnvironmentShadowing=false \n		bCastShadows=true \n		bDynamic=true \n	End Object \n \n	Begin Object Name=SkeletalMeshComponent0 \n		bDisableFaceFX=true \n		LightEnvironment=MyLightEnvironment \n \n		bHasPhysicsAssetInstance=true \n		bNoSelfShadow=true \n \n		BlockActors=false \n		BlockZeroExtent=false \n		BlockNonZeroExtent=false \n		CollideActors=false \n		BlockRigidBody=false \n	End Object \n \n	Begin Object Class=CylinderComponent Name=CollisionCylinder \n		CollisionRadius=21 \n		CollisionHeight=35 \n		CanBlockCamera = false \n		Translation=(Z=35) \n \n		BlockActors=true \n		BlockZeroExtent=true \n		BlockNonZeroExtent=true \n		CollideActors=true \n		BlockRigidBody=true \n	End Object \n	CollisionComponent=CollisionCylinder \n	Components.Add(CollisionCylinder) \n \n	TickOptimize = TickOptimize_None \n	IgnoreActorCollisionWhenHidden = true \n	IgnoreTickWhenHidden = false \n}");
                }
            }

        }

        private void Output_Click(object sender, EventArgs e)
        {
            string path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop); //It's a step in the right direction however not what I'm looking for specifically
            string pathString = System.IO.Path.Combine(path, "Output");
            System.IO.Directory.CreateDirectory(pathString);
            Process.Start(pathString);
        }
    }
}
