using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;

namespace Easy_Playable_Maker
{
	public partial class MainPlayableWindow : Form
	{
		public MainPlayableWindow()
		{
			InitializeComponent();
            TestBox.Hide();
            textBox1.Hide();
        }

        private void button1_Click(object sender, EventArgs e)
		{
			string[] Funnies = {"","","","","","","","","","","",""};
			//I don't wanna be known for my mods, but rather as that guy who puts recipes in his mods :)
			Funnies[0] = "\n \n/*\nobligatory developer jokes are old news, here is a recipe for banana bread \n \nIngredients \n \n    2 to 3 very ripe bananas, peeled (about 1 1/4 to 1 1/2 cups mashed) \n    1/3 cup melted butter, unsalted or salted \n    1 teaspoon baking soda \n    Pinch of salt \n    3/4 cup sugar (1/2 cup if you would like it less sweet, 1 cup if more sweet) \n    1 large egg, beaten \n    1 teaspoon vanilla extract \n    1 1/2 cups of all-purpose flour \n \nMethod \n \n1 Preheat the oven to 350°F (175°C), and butter a 4x8-inch loaf pan. \n \n2 In a mixing bowl, mash the ripe bananas with a fork until completely smooth. Stir the melted butter into the mashed bananas. \n \n3 Mix in the baking soda and salt. Stir in the sugar, beaten egg, and vanilla extract. Mix in the flour. \n \n4 Pour the batter into your prepared loaf pan. Bake for 50 minutes to 1 hour at 350°F (175°C), or until a tester inserted into the center comes out clean. \n \n5 Remove from oven and let cool in the pan for a few minutes. Then remove the banana bread from the pan and let cool completely before serving. Slice and serve. (A bread knife helps to make slices that aren't crumbly.) \n*/";
			Funnies[1] = "\n \n/*\nChocolate Chip Cookies: \n1 cup butter, softened \n \n1 cup white sugar \n \n1 cup packed brown sugar \n \n2 large eggs eggs \n \n2 teaspoons vanilla extract \n \n1 teaspoon baking soda \n \n2 teaspoons hot water \n \n½ teaspoon salt \n \n3 cups all-purpose flour \n \n2 cups semisweet chocolate chips \n \n1 cup chopped walnuts \n \nPreheat oven to 350 degrees F (175 degrees C). \n \nStep 2 \nCream together the butter, white sugar, and brown sugar until smooth. Beat in the eggs one at a time, then stir in the vanilla. Dissolve baking soda in hot water. Add to batter along with salt. Stir in flour, chocolate chips, and nuts. Drop by large spoonfuls onto ungreased pans. \n \nStep 3 \nBake for about 10 minutes in the preheated oven, or until edges are nicely browned.\n*/";
			Funnies[2] = "\n \n/*\nTexas Toast; \n8 tablespoons (1 stick) unsalted butter \n \n2 tablespoons olive oil \n \n5 cloves garlic, minced \n \n1/2 teaspoon dried parsley \n \n1/2 teaspoon dried garlic \n \n1/4 teaspoon kosher salt \n \n1/4 teaspoon freshly ground black pepper \n \n1 loaf soft white bread or Texas toast bread (14-inch, 12 ounces) \n \nArrange a rack in the middle of oven, place a rimmed baking sheet on the rack to preheat, and heat the oven to 375°F. \n \nMelt the butter in a medium microwave-safe bowl until completely melted, about 1 minute. Add the olive oil, minced garlic, parsley, garlic powder, salt, and pepper and stir to combine. Set aside while you slice the bread.   \n \nIf unsliced, slice the bread into 1-inch-thick slices. Use a pastry or basting brush to coat both sides of each slice with the garlic butter.   \n \nPlace the bread on the preheated baking sheet in a single layer. Bake until golden-brown, about 12 minutes. Serve warm. \n \nRECIPE NOTES \nGrill instructions: Heat an outdoor grill to medium heat and grill the toast for 2 minutes per side.\n*/";
			Funnies[3] = "\n \n/*\nGarlic Bread: \n1 16-ounce (450 g) loaf of Italian bread or French bread \n \n1/2 cup (1 stick, 112 g) unsalted butter, softened \n \n2 large cloves garlic, smashed and minced \n \n1 heaping tablespoon of freshly chopped parsley \n \n1/4 cup (25 g) freshly grated Parmesan cheese (optional) \n \nMETHOD 1: TOASTED GARLIC BREAD \n \n1 Preheat oven to 350°F.  \n \n2 Prepare the garlic bread: Cut the loaf in half, horizontally. Mix the butter, garlic, and parsley together in a small bowl. Spread butter mixture over the the two bread halves. \n \n3 Heat in oven for 10 min: Place on a sturdy baking pan (one that can handle high temperatures, not a cookie sheet) and heat in a 350°F (175°C) oven for 10 minutes. \n \n4 Sprinkle with Parmesan (optional) and broil: Remove pan from oven. Sprinkle Parmesan cheese over bread if you want. Return to oven on the highest rack. \n \nBroil on high heat for 2-3 minutes until the edges of the bread begin to toast and the cheese (if you are using cheese) bubbles. Watch very carefully while broiling. The bread can easily go from un-toasted to burnt. \n \n5 Slice: Remove from oven, let cool a minute. Remove from pan and use a bread knife to cut into 1-inch thick slices. Serve immediately. \n \nMETHOD 2: SOFT GARLIC BREAD \n \n1 Preheat oven to 350°F. Make the butter, garlic, parsley mixture as above. \n \n2 Slice the bread and insert butter mixture: Make 1-inch thick slices into the bread, but do not go all the way through, just to the bottom crust. Put a teaspoon or two of the butter mixture between each slice, or between every other slice if you only want the garlic mixture on one side of the bread. \n \n3 Bake the garlic bread: Wrap the bread in aluminum foil and heat for 15 minutes in the 350°F (175°C) oven, until the butter has melted and the bread is warmed. \n \n4 Serve: To serve, remove from foil and present the loaf wrapped in a clean tea towel. Tear off slices to eat.\n*/";
			Funnies[4] = "\n \n/*\nPepcorn: \n20 cups popped popcorn \n \n1/2 cup butter or margarine, melted \n \n2 teaspoons paprika \n \n2 teaspoons lemon pepper \n \n1 teaspoon salt \n \n1 teaspoon garlic powder \n \n1 teaspoon onion powder \n \n1/4 teaspoon cayenne pepper \n \nAny BDG fans out there! makin some good pepcorn in me scripts :) \n \nStep 1 \nPreheat the oven to 350 degrees F (175 degrees C). Place the popped popcorn in a large roasting pan. \n \nStep 2 \nIn a small bowl, stir together the melted butter, paprika, lemon pepper, salt, garlic powder, onion powder, and cayenne pepper. Pour over the popcorn and stir until it is somewhat evenly coated. \n \nStep 3 \nBake for 15 minutes, stirring every 5 minutes. Remove from the oven and cool completely. Serve immediately, or store in an airtight container for later.\n*/";
			Funnies[5] = "\n \n/*\nPancakes: \n1 1/2 cups all-purpose flour \n \n3 1/2 teaspoons baking powder \n \n1 teaspoon salt \n \n1 tablespoon white sugar \n \n1 1/4 cups milk \n \n1 egg \n \n3 tablespoons butter, melted \n \nStep 1 \nIn a large bowl, sift together the flour, baking powder, salt and sugar. Make a well in the center and pour in the milk, egg and melted butter; mix until smooth. \n \nStep 2 \nHeat a lightly oiled griddle or frying pan over medium high heat. Pour or scoop the batter onto the griddle, using approximately 1/4 cup for each pancake. Brown on both sides and serve hot.\n*/";
			Funnies[6] = "\n \n/*\nChicken Soup: \n1 (3 pound) whole chicken \n \n4 medium (blank)s carrots, halved \n \n4 stalks celery, halved \n \n1 large onion, halved \n \nwater to cover \n \nsalt and pepper to taste \n \n1 teaspoon chicken bouillon granules \n \nStep 1 \nPut the chicken, carrots, celery and onion in a large soup pot and cover with cold water. Heat and simmer, uncovered, until the chicken meat falls off of the bones (skim off foam every so often). \n \nStep 2 \nTake everything out of the pot. Strain the broth. Pick the meat off of the bones and chop the carrots, celery and onion. Season the broth with salt, pepper and chicken bouillon to taste, if desired. Return the chicken, carrots, celery and onion to the pot, stir together, and serve.\n*/";
			Funnies[7] = "\n \n/*\nCheddar Broccoli Soup: \n1 tablespoon butter \n \n1/2 onion, chopped \n \n1/4 cup melted butter \n \n1/4 cup flour \n \n2 cups milk \n \n2 cups chicken stock \n \n1 1/2 cups coarsely chopped broccoli florets \n \n1 cup matchstick-cut carrots \n \n1 stalk celery, thinly sliced \n \n2 1/2 cups shredded sharp Cheddar cheese \n \nsalt and ground black pepper to taste \n \nStep 1 \nMelt 1 tablespoon butter in a skillet over medium-high heat. Saute onion in hot butter until translucent, about 5 minutes. Set aside. \n \nStep 2 \nWhisk 1/4 cup melted butter and flour together in a large saucepan over medium-low heat; cook until flour loses it's granular texture, adding 1 to 2 tablespoons of milk if necessary to keep the flour from burning, 3 to 4 minutes. \n \nStep 3 \nGradually pour milk into flour mixture while whisking constantly. Stir chicken stock into milk mixture. Bring to a simmer; cook until flour taste is gone and mixture is thickened, about 20 minutes. Add broccoli, carrots, sauteed onion, and celery; simmer until vegetables are tender, about 20 minutes. \n \nStep 4 \nStir Cheddar cheese into vegetable mixture until cheese melts. Season with salt and pepper to taste.\n*/";
			Funnies[8] = "\n \n/*\nNew York styled Ice Cream: \n2 cups heavy cream \n1 cup whole milk \n2/3 cup sugar \n1/8 teaspoon fine sea salt \n6 large egg yolks \n Your choice of flavoring (see note) \n  \nIn a small pot, simmer heavy cream, milk, sugar and salt until sugar completely dissolves, about 5 minutes. Remove pot from heat. In a separate bowl, whisk yolks. Whisking constantly, slowly whisk about a third of the hot cream into the yolks, then whisk the yolk mixture back into the pot with the cream. Return pot to medium-low heat and gently cook until mixture is thick enough to coat the back of a spoon (about 170 degrees on an instant-read thermometer). \n \nStrain through a fine-mesh sieve into a bowl. Cool mixture to room temperature. Cover and chill at least 4 hours or overnight. Churn in an ice cream machine according to manufacturers’ instructions. Serve directly from the machine for soft serve, or store in freezer until needed. \n \nTip \nThis recipe for ice cream base may be churned on its own, but it is meant to have flavors added. See the chart here for flavor options and directions for incorporating them into the base recipe.\n*/";
			Funnies[9] = "\n \n/*\nCrab Rangoon: \n5 oz can of crab meat drained (can be substituted with fresh or packaged crab) \n \n4 oz cream cheese softened4 oz cream cheese softened \n \n1 green onion finely sliced1 green onion finely sliced \n \n1/4 teaspoon garlic powder1/4 teaspoon garlic powder \n \n1 teaspoon Worcestershire sauce1 teaspoon Worcestershire sauce \n \n18 won ton wrappers18 won ton wrappers \n \noil for fryingoil for frying \n \nInstructions \nPreheat 1 inch of oil to 325°F over medium heat. \nIn a small bowl, gently combine crab meat, cream cheese, green onion, garlic powder, and Worcestershire sauce. \nLayout 3 wonton wrappers at a time. Place 2 teaspoons of the filling in the center of each. Dab the edges with water and fold the two opposite corners together to form a triangle. Wet the tips of the triangle and fold inward. Continue until all of your filling is used up. \n \nTo Fry \nDrop the wontons into the hot oil for 2-3 minutes or until brown and crispy. Drain on paper towels. \n \nTo Bake \nPreheat oven to 425°F. Line a baking pan with parchment paper. \nAssemble wontons as above and spray each with cooking spray. Bake 12-14 minutes.\n*/";
			Funnies[10] = "\n \n/*\nCurrywurst: \n \nCourtesy of Dranif! \n \nStep 1: \nGet a rather thick sausage and cut it into pieces (and warm it up) \n \nStep 2: \nMake some fries as garnish \n \nStep 3: \nAdd some (flavoured) Ketchup \n \nStep 4: \nAdd curry spice\n*/";
			Funnies[11] = "\n \n/*\n3 in 1 Fry sauce combo: \n \nFrench Fry Sauce \n1/3 cup ketchup \n2/3 cup mayonnaise \n1 tsp pickle juice \n \nGarlic Aioli \n1 cup mayonnaise \n1 TBS garlic (minced) \n2 TBS lemon juice \n1/2 tsp salt \n1 pinch black pepper \n \nCheese Sauce \n8 oz Velveeta Cheese \n1/2 cup milk \nInstructions \n \nFry Sauce \nCombine ketchup, mayonnaise, pickle juice in a medium sized bowl \nStir together until smooth \n \nGarlic Aioli \nCombine your mayo, lemon juice, garlic, salt, pepper in a medium bowl, \nStir until everything is smooth \nRefrigerate for 30 minutes before serving \n \nCheese Sauce \nCut your Velveeta cheese into small cubes \nIn a small pot over medium high heat, put your cheese cubes and milk \nStirring regularly, allow cheese to melt into milk, until smooth\n*/";

			string path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop); 
			string pathString = System.IO.Path.Combine(path, "Output");

			if (String.IsNullOrEmpty(IceStatueText.Text)) { IceStatueText.Text = "StaticMesh'HatinTime_Habboi.models.hat_kid_crystal'"; }
			if (String.IsNullOrEmpty(PlayerIconText.Text)) { PlayerIconText.Text = "None"; }
			if (String.IsNullOrEmpty(PrefixText.Text)) { PrefixText.Text = "Kido"; }
			if (String.IsNullOrEmpty(PlayerNameText.Text)) { PlayerNameText.Text = "PLAYERNAME"; }
			if (String.IsNullOrEmpty(VirtFullText.Text)) { VirtFullText.Text = "None"; }
			if (String.IsNullOrEmpty(VirtLegsText.Text)) { VirtLegsText.Text = "None"; }
			if (String.IsNullOrEmpty(VirtBodyText.Text)) { VirtBodyText.Text = "None"; }
			if (String.IsNullOrEmpty(VirtHeadText.Text)) { VirtHeadText.Text = "None"; }
			if (String.IsNullOrEmpty(FullModelText.Text)) { FullModelText.Text = "None"; }
			if (String.IsNullOrEmpty(LegsText.Text)) { LegsText.Text = "None"; }
			if (String.IsNullOrEmpty(BodyText.Text)) { BodyText.Text = "None"; }
			if (String.IsNullOrEmpty(HeadText.Text)) { HeadText.Text = "None"; }
			if (String.IsNullOrEmpty(PonytailText.Text)) { PonytailText.Text = "-1"; }
			if (String.IsNullOrEmpty(FaceText.Text)) { FaceText.Text = "-1"; }
			if (String.IsNullOrEmpty(EyesText.Text)) { EyesText.Text = "-1"; }
			if (String.IsNullOrEmpty(RadFullText.Text)) { RadFullText.Text = "None"; }
			if (String.IsNullOrEmpty(RadEXPText.Text)) { RadEXPText.Text = "class'Hat_ExpressionComponent_HatKid'"; }
			if (String.IsNullOrEmpty(RadLegsText.Text)) { RadLegsText.Text = "None"; }
			if (String.IsNullOrEmpty(RadBodyText.Text)) { RadBodyText.Text = "None"; }
			if (String.IsNullOrEmpty(RadHeadText.Text)) { RadHeadText.Text = "None"; }
			if (String.IsNullOrEmpty(WireEXPText.Text)) { WireEXPText.Text = "class'Hat_ExpressionComponent_HatKid'"; }
			if (String.IsNullOrEmpty(ShadowEXPText.Text)) { ShadowEXPText.Text = "class'Hat_ExpressionComponent_ShadowPuppet'"; }
			if (String.IsNullOrEmpty(BaseEXPText.Text)) { BaseEXPText.Text = "class'Hat_ExpressionComponent_HatKid'"; }
			if (String.IsNullOrEmpty(BText.Text)) { BText.Text = "174"; }
			if (String.IsNullOrEmpty(GText.Text)) { GText.Text = "217"; }
			if (String.IsNullOrEmpty(RText.Text)) { RText.Text = "255"; }
			if (String.IsNullOrEmpty(WireFullText.Text)) { WireFullText.Text = "None"; }
			if (String.IsNullOrEmpty(WireLegsText.Text)) { WireLegsText.Text = "None"; }
			if (String.IsNullOrEmpty(WireBodyText.Text)) { WireBodyText.Text = "None"; }
			if (String.IsNullOrEmpty(WireHeadText.Text)) { WireHeadText.Text = "None"; }
			if (String.IsNullOrEmpty(PlushFullText.Text)) { PlushFullText.Text = "None"; }
			if (String.IsNullOrEmpty(PlushLegsText.Text)) { PlushLegsText.Text = "None"; }
			if (String.IsNullOrEmpty(PlushBodyText.Text)) { PlushBodyText.Text = "None"; }
			if (String.IsNullOrEmpty(PlushHeadText.Text)) { PlushHeadText.Text = "None"; }
			if (String.IsNullOrEmpty(InvisibleText.Text)) { InvisibleText.Text = "None"; }
			if (String.IsNullOrEmpty(DoodleText.Text)) { DoodleText.Text = "None"; }

			string fileName = PrefixText.Text+"_Player_"+PlayerNameText.Text+".uc";
			pathString = System.IO.Path.Combine(pathString, fileName);


			Random rand = new Random();
			int index = rand.Next(Funnies.Length);


			if (!System.IO.File.Exists(pathString))
			{
				using (StreamWriter writer = new StreamWriter(pathString))
				{
					writer.WriteLine("class " + PrefixText.Text + "_Player_" + PlayerNameText.Text + " extends Hat_Player_HatKid;");
					writer.WriteLine(Funnies[index]);
					writer.WriteLine("\nvar transient bool DidCutsceneFix; \nvar transient bool OverrideHeadMesh; \nvar transient bool CleanFaceNextSkinUpdate; \nvar transient bool CancelAnimationOnLand; \n \nvar(Mesh) SkeletalMesh  Head; \nvar(Mesh) SkeletalMesh	Body; \nvar(Mesh) SkeletalMesh	Legs; \nvar(Mesh) SkeletalMesh	FullModel; \n \nvar(Mesh) SkeletalMesh	RadHead; \nvar(Mesh) SkeletalMesh	RadBody; \nvar(Mesh) SkeletalMesh	RadLegs; \nvar(Mesh) SkeletalMesh	RadFull; \n \nvar(Mesh) SkeletalMesh	PlushHead; \nvar(Mesh) SkeletalMesh	PlushBody; \nvar(Mesh) SkeletalMesh	PlushLegs; \nvar(Mesh) SkeletalMesh	PlushFull; \n \nvar(Mesh) SkeletalMesh	WireHead; \nvar(Mesh) SkeletalMesh	WireBody; \nvar(Mesh) SkeletalMesh	WireLegs; \nvar(Mesh) SkeletalMesh	WireFull; \n \nvar(Mesh) SkeletalMesh	VirtHead; \nvar(Mesh) SkeletalMesh	VirtBody; \nvar(Mesh) SkeletalMesh	VirtLegs; \nvar(Mesh) SkeletalMesh	VirtFull; \n \nvar(Mesh) SkeletalMesh  FlatHead; \nvar(Mesh) SkeletalMesh  InvisMesh; \n \nvar(Mesh) SkeletalMeshComponent BodyOcc; \nvar(Mesh) SkeletalMeshComponent LegsOcc; \n \nsimulated function PostPostBeginPlay() \n{ \n	Super.PostPostBeginPlay(); \n} \n \nsimulated function UpdateSkin() \n{ \n	local int i; \n	local Hat_Loadout loadout; \n	local Hat_PlayerController pc; \n \n    OverrideHeadMesh = true; \n \n	pc = (Controller != None && Controller.IsA('Hat_PlayerController')) ? Hat_PlayerController(Controller) : None; \n	if (pc == None && DrivenVehicle != None && DrivenVehicle.Controller != None && DrivenVehicle.Controller.IsA('Hat_PlayerController')) \n		pc = Hat_PlayerController(DrivenVehicle.Controller); \n \n	if (Hat_PlayerReplicationInfo(PlayerReplicationInfo) != None) \n		loadout = Hat_PlayerReplicationInfo(PlayerReplicationInfo).MyLoadout; \n \n	if (loadout == None) loadout = (pc != None) ? pc.GetLoadout() : None; \n \n	if (CleanFaceNextSkinUpdate) \n	{ \n		// set head to default \n		Mesh.SetSkeletalMesh(Mesh.default.SkeletalMesh); \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n		class'Hat_Collectible_Skin'.static.SetExpressionComponent(self); \n		CleanFaceNextSkinUpdate = false; \n	} \n \n	Super.UpdateSkin(); \n	DoSkinOverrides(); \n \n	SetMaterialVectorValue('BodySkinColor', class'Hat_Math'.static.ColorToLinear(SkinColor)); \n} \n \nsimulated event Tick(float d) \n{ \n	Super.Tick(d); \n} \n \nsimulated event Destroyed() \n{ \n	Super.Destroyed(); \n} \n \nsimulated function AudioComponent PlayVoice(SoundCue c, optional float relaxtime = 0, optional bool ignorerelax, optional bool isconversation) \n{ \n	local AudioComponent a; \n \n	a = Super.PlayVoice(c, relaxtime, ignorerelax); \n \n	if (a != None && !isconversation) \n	{ \n		a.PitchMultiplier = 1; \n	} \n	return a; \n} \n \n \nstatic function class RadWave() { \n    local GameModInfo gmi; \n \n   gmi = getModInfo(\"1808353917\"); \n \n    if (gmi.ModClass != None) { \n        //note: returns None if can't be found. Test appropriately. \n        return class'Hat_ClassHelper'.static.ClassFromName( \n            \"Ctm_Collectible_Trash_Vaporwave\", \n            string(gmi.ModClass.GetPackageName()) \n        ); \n    } \n    return None; \n} \n \nstatic function class PlushKids() { \n    local GameModInfo gmi; \n \n    gmi = getModInfo(\"1751928588\"); \n \n    if (gmi.ModClass != None) { \n        //note: returns None if can't be found. Test appropriately. \n        return class'Hat_ClassHelper'.static.ClassFromName( \n            \"Collectible_Skin_PlushKid\", \n			string(gmi.ModClass.GetPackageName()) \n        ); \n    } \n    return None; \n} \n \nstatic function class FlatKid() { \n    local GameModInfo gmi; \n \n    gmi = getModInfo(\"2043720741\"); \n \n    if (gmi.ModClass != None) { \n        //note: returns None if can't be found. Test appropriately. \n        return class'Hat_ClassHelper'.static.ClassFromName( \n            \"Arg_Collectible_Skin_FlatKid\", \n			string(gmi.ModClass.GetPackageName()) \n        ); \n    } \n    return None; \n} \n \nstatic function int FindGameModID(string InString) { \n    local array<GameModInfo> GMs; \n    local int i; \n \n    GMs = class'GameMod'.static.GetModList(); \n    for(i = 0; i < GMs.Length; i++) \n    { \n        if (class'GameMod'.static.GetModIDString(GMs[i].WorkshopID) == InString) \n            return GMs[i].WorkshopID; \n    } \n    return INDEX_NONE; \n} \n \nstatic function GameModInfo GetModInfo(string WorkshopID)  { \n    local int i; \n    local Array<GameModInfo> ModList; \n    local int WorkshopIndex; \n    local GameModInfo Fake; \n \n    WorkshopIndex = FindGameModID(WorkshopID); \n    ModList = class'GameMod'.static.GetModList(); \n \n    for(i = 0; i < ModList.Length; i++) { \n        if(ModList[i].WorkshopID == WorkshopIndex) { \n            return ModList[i]; \n        } \n    } \n    return Fake; \n} \n \n \nstatic function ApplySkin(Actor ply, optional class<Hat_Collectible_Skin> Skin) \n{ \n	local SkeletalMeshComponent ArgleUpperBodyMesh, ArgleLegsMesh; \n	if (ply.IsA('Arg_GhostPartyPlayer')) \n	{ \n		ArgleUpperBodyMesh = GetArglePlayerUpperBody(ply); \n		ArgleLegsMesh = GetArglePlayerLegs(ply); \n	} \n \n	ApplyDefaultSkin(ply, ArgleUpperBodyMesh, ArgleLegsMesh); \n	InitAllMaterials(ply); \n	ApplySupportedSkin(ply, Skin, ArgleUpperBodyMesh, ArgleLegsMesh); \n	UpdateColorsTextures(ply, Skin); \n	Skin.static.SetExpressionComponent(ply); \n \n} \n \n \nstatic function ApplySupportedSkin(Actor ply, class<Hat_Collectible_Skin> Skin, optional SkeletalMeshComponent ArgUpperBody, optional SkeletalMeshComponent ArgLegs) //Let's begin! Let's check if our skin is the vanilla one... \n{ \n	ApplyCustomSkin(ply, Skin, ArgUpperBody, ArgLegs); \n} \n \n \nstatic function ApplySkinArglePlayer(Actor ply, class<Hat_Collectible_Skin> Skin, SkeletalMeshComponent ArgUpperBody, SkeletalMeshComponent ArgLegs) \n{ \n	if (ply.IsA('Arg_GhostPartyPlayer') && Hat_GhostPartyPlayer(ply) != None && ArgUpperBody != None && ArgLegs != None) \n	{ \n		UpdateColorsTextures(ply, Skin); \n	} \n} \n \nstatic function ApplyCustomSkin(Actor ply, class<Hat_Collectible_Skin> Skin, optional SkeletalMeshComponent ArgUpperBody, optional SkeletalMeshComponent ArgLegs) //So our skin is not the vanilla one... \n{ \n \n		if (ply.IsA('Arg_GhostPartyPlayer')) \n			ApplySkinArglePlayer(ply, Skin, ArgUpperBody, ArgLegs); \n		else \n			Skin.static.Apply(ply); \n \n		if (Skin.default.SkinBodyMesh == None && Skin.default.SkinLegsMesh == None) \n		{ \n			if (ply.IsA('Arg_GhostPartyPlayer') || ply.IsA('Hat_NPC_Player')) \n				ApplyDefaultSkin(ply, ArgUpperBody, ArgLegs); \n		} \n \n \n} \n \nstatic function class<Hat_Player> GetPlayerClassByActor(Actor P) //Quick the more you know section: this function supports all 3 types of player while the scripts of main game support only 2 of them. And in each case different ones. \n{ \n	local class<Hat_Player> PlayerClass; \n	PlayerClass = None; \n	if (P.IsA('Hat_Player')) PlayerClass = class<Hat_Player>(P.Class); \n	else if (P.IsA('Hat_NPC_Player')) PlayerClass = class<Hat_Player>(Hat_NPC_Player(P).GetPlayerPawn().Class); \n	else if (P.IsA('Hat_GhostPartyPlayer') || P.IsA('Arg_GhostPartyPlayer')) \n	{ \n		PlayerClass = Hat_GhostPartyPlayer(P).PlayerVisualClass; \n		if (PlayerClass == None) PlayerClass = class'Hat_Player_HatKid'; \n	} \n	return PlayerClass; \n} \n \n \nstatic function ResetHead(Actor ply, bool IsOnlyHead, bool IsLongArms, bool ResMat) //Setting different heads and resetting materials if needed. \n{ \n	local SkeletalMeshComponent comp; \n	local class<Hat_Player> PlayerClass; \n	comp = GetMainMeshByPlayerClass(ply); \n	PlayerClass = GetPlayerClassByActor(ply); \n	if (class<" + PrefixText.Text + "_Player_" + PlayerNameText.Text + ">(PlayerClass) == None) \n		return; \n	if (comp != None) \n	{ \n		if (Hat_GhostPartyPlayer(ply) != None) \n		{ \n			if (comp.SkeletalMesh != class<" + PrefixText.Text + "_Player_" + PlayerNameText.Text + ">(PlayerClass).default.Head) \n				comp.SetSkeletalMesh(class<" + PrefixText.Text + "_Player_" + PlayerNameText.Text + ">(PlayerClass).default.Head); \n		} \n		else if ((Hat_GhostPartyPlayer(ply) != None && ply.IsA('Arg_GhostPartyPlayer')) || Hat_Player(ply) != None || Hat_NPC_Player(ply) != None) \n		{ \n			if (IsOnlyHead) \n			{ \n				if (comp.SkeletalMesh != class<" + PrefixText.Text + "_Player_" + PlayerNameText.Text + ">(PlayerClass).default.Head) \n					comp.SetSkeletalMesh(class<" + PrefixText.Text + "_Player_" + PlayerNameText.Text + ">(PlayerClass).default.Head); \n			} \n		} \n	} \n} \n \nstatic function SkeletalMeshComponent GetArglePlayerUpperBody(Actor P) \n{ \n	return GetArgleComponentByType(P, 0); \n} \n \nstatic function SkeletalMeshComponent GetArglePlayerLegs(Actor P) \n{ \n	return GetArgleComponentByType(P, 1); \n} \n \n \nstatic function SkeletalMeshComponent GetArgleComponentByType(Actor P, int t) \n{ \n	local Hat_GhostPartyPlayer gpp; \n	local Array<SkeletalMeshComponent> comps; \n	local SkeletalMeshComponent comp, UpperBodyComp, LegsComp; \n	local int i; \n	if ((t == 0 || t == 1) && P.IsA('Arg_GhostPartyPlayer') && Hat_GhostPartyPlayer(P) != None) \n	{ \n		gpp = Hat_GhostPartyPlayer(P); \n		foreach gpp.ComponentList(class'SkeletalMeshComponent', comp) \n		{ \n			if (comp.ParentAnimComponent == gpp.SkeletalMeshComponent) \n				comps.AddItem(comp); \n		} \n		for (i = 0; i < comps.Length; i++) \n		{ \n			if (comps[i].default.SkeletalMesh == SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidBody') \n				UpperBodyComp = comps[i]; \n			else if (comps[i].default.SkeletalMesh == SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidLegs') \n				LegsComp = comps[i]; \n			if (t == 0) \n				return UpperBodyComp; \n			else \n				return LegsComp; \n		} \n	} \n	return None; \n} \n \n \n \nstatic function class<Hat_Collectible_Skin> NPCGetCurrentSkin(Hat_NPC_Player npc) \n{ \n	local Hat_Loadout MyLoadout; \n	local class<Hat_Collectible_Skin> SkinClass; \n	MyLoadout = npc.GetLoadout(); \n	SkinClass = (MyLoadout != None && MyLoadout.MyLoadout.Skin != None && MyLoadout.MyLoadout.Skin.BackpackClass != None) ? class<Hat_Collectible_Skin>(MyLoadout.MyLoadout.Skin.BackpackClass) : class'Hat_Collectible_Skin'; \n	return SkinClass; \n} \n \n \nstatic function ApplyMainMeshMaterialsToAttachments(Actor ply) \n{ \n	local SkeletalMeshComponent MainMesh; \n	local Array<SkeletalMeshComponent> Attachments; \n	local int i; \n	MainMesh = GetMainMeshByPlayerClass(ply); \n	Attachments = GetAccessoriesArrayByPlayerClass(ply); \n	for (i = 0; i < Attachments.Length; i++) \n	{ \n		Attachments[i].SetMaterial(0, MainMesh.GetMaterial(1)); \n		class'Hat_NPC'.static.InitMaterialInstancesMesh(Attachments[i]); \n	} \n} \n \n \nstatic function OnHiddenExpression(Actor ply) \n{ \n	local SkeletalMeshComponent MainMesh; \n	MainMesh = GetMainMeshByPlayerClass(ply); \n	if (MainMesh.SkeletalMesh == default.Mesh.SkeletalMesh && MainMesh.GetMaterial(default.MaterialIndexEyes).GetMaterial() == Material'HatInTime_Characters.Materials.Invisible') \n		MainMesh.SetMaterial(default.MaterialIndexEyes, MainMesh.GetMaterial(1)); \n	if (MainMesh.SkeletalMesh == default.Mesh.SkeletalMesh && MainMesh.GetMaterial(default.MaterialIndexFace).GetMaterial() == Material'HatInTime_Characters.Materials.Invisible') \n		MainMesh.SetMaterial(default.MaterialIndexFace, MainMesh.GetMaterial(1)); \n} \n \n \nstatic function SkeletalMeshComponent GetMainMeshByPlayerClass(Actor ply) \n{ \n	local SkeletalMeshComponent MainMesh; \n	if (Hat_Player(ply) != None) MainMesh = Hat_Player(ply).Mesh; \n	else if (Hat_NPC_Player(ply) != None) MainMesh = Hat_NPC_Player(ply).SkeletalMeshComponent; \n	else if (Hat_GhostPartyPlayer(ply) != None) MainMesh = Hat_GhostPartyPlayer(ply).SkeletalMeshComponent; \n	return MainMesh; \n} \n \nstatic function Array<SkeletalMeshComponent> GetAccessoriesArrayByPlayerClass(Actor ply) \n{ \n	local SkeletalMeshComponent MainMesh, comp; \n	local Array<SkeletalMeshComponent> AccessoriesComponents; \n	AccessoriesComponents.Length = 4; \n	MainMesh = GetMainMeshByPlayerClass(ply); \n	foreach MainMesh.AttachedComponents(class'SkeletalMeshComponent', comp) \n	{ \n \n	} \n	return AccessoriesComponents; \n} \n \n \nstatic function UpdateColorsTextures(Actor ply, class<Hat_Collectible_Skin> Skin) \n{ \n	local int i; \n	local SkinColors iSkinColor; \n	local LinearColor lc; \n	local Color c; \n	local Texture2D Tex; \n	local Name ParName; \n	local Array<Texture2D> TextureSlots; \n \n	if (Skin == None) \n		Skin = class'Hat_Collectible_Skin'; \n \n	Skin.static.GetTextureSlotList(TextureSlots); \n	Skin.static.SetTextureSlots(ply, TextureSlots); \n \n	for (i = 0; i < Skin.const.SkinColorNum; i++) \n	{ \n		iSkinColor = SkinColors(i); \n		ParName = Name(class'Hat_Collectible_Skin'.static.GetSkinColorName(iSkinColor)); \n \n		c = Skin.default.SkinColor[iSkinColor]; \n		Tex = Skin.default.SkinTextureInfo[iSkinColor].Texture; \n		if (Skin.static.IsSlotEmpty(c, Tex) && iSkinColor == SkinColor_HatAlt) \n		{ \n			iSkinColor = SkinColor_Hat; \n			if (Skin.static.IsSlotEmptyByIndex(iSkinColor)) \n				iSkinColor = SkinColor_Dress; \n \n			if (!Skin.static.IsSlotEmptyByIndex(iSkinColor)) \n			{ \n				c = Skin.default.SkinColor[iSkinColor]; \n				Tex = Skin.default.SkinTextureInfo[iSkinColor].Texture; \n				c.R *= 0.6; \n				c.G *= 0.6; \n				c.B *= 0.6; \n			} \n		} \n		if (Skin.static.IsSlotEmpty(c, Tex) && iSkinColor == SkinColor_Hat) \n		{ \n			iSkinColor = SkinColor_Dress; \n			if (!Skin.static.IsSlotEmptyByIndex(iSkinColor)) \n			{ \n				c = Skin.default.SkinColor[iSkinColor]; \n				Tex = Skin.default.SkinTextureInfo[iSkinColor].Texture; \n			} \n		} \n		if (Skin.static.IsSlotEmpty(c, Tex) && iSkinColor == SkinColor_HatBand) \n		{ \n			iSkinColor = SkinColor_Cape; \n			if (!Skin.static.IsSlotEmptyByIndex(iSkinColor)) \n			{ \n				c = Skin.default.SkinColor[iSkinColor]; \n				Tex = Skin.default.SkinTextureInfo[iSkinColor].Texture; \n			} \n		} \n \n		if (Skin.static.IsSlotEmpty(c, Tex)) \n		{ \n			ClearMaterialVectorValueByActor(ply, ParName); \n		} \n		else \n		{ \n			if (Tex != None) \n			{ \n				lc.R = Skin.default.SkinTextureInfo[iSkinColor].UVScale * (Skin.default.SkinTextureInfo[iSkinColor].DisableNormalMap ? -1 : 1); \n				lc.G = Skin.default.SkinTextureInfo[iSkinColor].Angle; \n				lc.B = 0; \n				lc.A = TextureSlots.Find(Tex); \n			} \n			else \n			{ \n				lc.R = (float(c.R)/255.f) ** 2; \n				lc.G = (float(c.G)/255.f) ** 2; \n				lc.B = (float(c.B)/255.f) ** 2; \n				lc.A = -1; \n			} \n \n			SetMaterialVectorValueByActor(ply, ParName, lc); \n		} \n	} \n} \n \n \nstatic function SetMaterialVectorValueByActor(Actor a, Name n, LinearColor v) \n{ \n	local Array<MeshComponent> MeshComponents; \n	local int i; \n	MeshComponents = GetAllMeshComponentsByActor(a); \n	for (i = 0; i < MeshComponents.Length; i++) \n	{ \n		if (Hat_Player(a) != None) \n			Hat_Player(a).SetMaterialVectorValueMesh(MeshComponents[i], n, v); \n		else \n			class'Hat_NPC'.static.SetMaterialVectorValueMesh(MeshComponents[i], n, v); \n	} \n} \n \nstatic function ClearMaterialVectorValueByActor(Actor a, Name n) \n{ \n	local Array<MeshComponent> MeshComponents; \n	local int i; \n	MeshComponents = GetAllMeshComponentsByActor(a); \n	for (i = 0; i < MeshComponents.Length; i++) \n	{ \n		if (Hat_Player(a) != None) \n			Hat_Player(a).ClearMaterialVectorValueMesh(MeshComponents[i], n); \n		else \n			class'Hat_NPC'.static.ClearMaterialVectorValueMesh(MeshComponents[i], n); \n	} \n} \n \nstatic function InitAllMaterials(Actor a) \n{ \n	local int i; \n	local Array<MeshComponent> MeshComponents; \n	MeshComponents = GetAllMeshComponentsByActor(a); \n \n	for (i = 0; i < MeshComponents.Length; i++) \n	{ \n		if (Hat_Player(a) != None) Hat_Player(a).InitMaterialInstancesMesh(MeshComponents[i]); \n		else class'Hat_NPC'.static.InitMaterialInstancesMesh(MeshComponents[i]); \n	} \n} \n \n \nstatic function Array<MeshComponent> GetAllMeshComponentsByActor(Actor a) \n{ \n	local Hat_Player ply; \n	local Hat_NPC_Player npc; \n	local Hat_GhostPartyPlayer gpp; \n	local Array<MeshComponent> MeshComponents; \n	local MeshComponent comp; \n \n	ply = Hat_Player(a); \n	npc = Hat_NPC_Player(a); \n	`if(`isdefined(WITH_GHOSTPARTY)) \n	gpp = Hat_GhostPartyPlayer(a); \n	`endif \n \n	if (ply != None) MeshComponents = ply.GetMyMaterialMeshComponents(); \n	else if (npc != None) MeshComponents = npc.GetMyMaterialMeshComponents(); \n	`if(`isdefined(WITH_GHOSTPARTY)) \n	else if (gpp != None) \n	{ \n		MeshComponents = gpp.GetMyMaterialMeshComponents(); \n		foreach gpp.SkeletalMeshComponent.AttachedComponents(class'MeshComponent', comp) \n		{ \n			if (MeshComponents.Find(comp) == INDEX_NONE) \n				MeshComponents.AddItem(comp); \n		} \n	} \n	`endif \n	return MeshComponents; \n} \n \n \n \n \nstatic function ConvertGhostPartyPlayer(Hat_GhostPartyPlayer gp) \n{ \n \n	if (gp.SkeletalMeshComponent == None) return; \n	gp.SkeletalMeshComponent.SetSkeletalMesh(default.FullModel); \n	gp.SkeletalMeshComponent.SetPhysicsAsset(PhysicsAsset'HatinTime_Characters_CoPartner.Physics.CoPartner_Physics'); \n	gp.SkeletalMeshComponent.SetMaterial(0, None); \n	gp.SkeletalMeshComponent.SetMaterial(1, None); \n	gp.SkeletalMeshComponent.SetMaterial(2, None); \n	gp.SkeletalMeshComponent.SetMaterial(3, None); \n	gp.SkeletalMeshComponent.SetMaterial(4, None); \n	gp.SkeletalMeshComponent.SetMaterial(5, None); \n \n} \n \nstatic function ApplyDefaultSkin(Actor ply, optional SkeletalMeshComponent ArgUpperBody, optional SkeletalMeshComponent ArgLegs) \n{ \n	ResetHead(ply, false, false, true); \n \n	class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', ply, default.Body, None); \n	class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', ply, default.Legs, None); \n \n} \n \nsimulated function Array<MeshComponent> GetMyMaterialMeshComponents() \n{ \n	local Hat_CosmeticItem CosmeticItem; \n \n	if (OverrideHeadMesh) \n	{ \n		// replace body meshes before any dyes/patterns are applied \n		foreach InvManager.InventoryActors(class'Hat_CosmeticItem', CosmeticItem) \n		{ \n			if (SkeletalMeshComponent(CosmeticItem.DroppedPickupMesh) == None) continue; \n			if (SkeletalMeshComponent(CosmeticItem.DroppedPickupMesh).SkeletalMesh == SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidBody') \n				class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, Body, None); \n			if (SkeletalMeshComponent(CosmeticItem.DroppedPickupMesh).SkeletalMesh == SkeletalMesh'HatInTime_Characters_HatKid.models.HatKidLegs') \n				class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, Legs, None); \n		} \n		// only need to do it once \n		OverrideHeadMesh = false; \n	} \n \n	return Super.GetMyMaterialMeshComponents(); \n} \n \nfunction simulated PostBeginPlay() \n{ \n	Super.PostBeginPlay(); \n \n \n	SetTimer(3, false, NameOf(FixTheOcclusion)); \n} \n \nfunction simulated FixTheOcclusion(Optional SkeletalMesh BodyMesh, Optional SkeletalMesh LegsMesh, Optional class<Hat_Collectible_Skin> Skin){ \n	local Hat_CosmeticItem CosmeticItem; \n \n	//Validation for custom skins that use overides \n	if(Skin == class'Hat_Collectible_Skin_HatKid64'){ \n		BodyOcc.SetSkeletalMesh(VirtBody); \n		LegsOcc.SetSkeletalMesh(VirtLegs); \n	} \n	else if(Skin == class'Hat_Collectible_Skin_Wireframe'){ \n		BodyOcc.SetSkeletalMesh(WireBody); \n		LegsOcc.SetSkeletalMesh(WireLegs); \n	} \n	else if(Skin == Radwave()){ \n		BodyOcc.SetSkeletalMesh(RadBody); \n		LegsOcc.SetSkeletalMesh(RadLegs); \n	} \n	else if(Skin == PlushKids()){ \n		BodyOcc.SetSkeletalMesh(PlushBody); \n		LegsOcc.SetSkeletalMesh(PlushLegs); \n	} \n	else if(Skin == FlatKid()){ \n		//This will be fun :) \n	} \n	else{ \n		if(BodyMesh != none){ \n			BodyOcc.SetSkeletalMesh(BodyMesh); \n		} \n		else{ \n			BodyOcc.SetSkeletalMesh(Body); \n		} \n		if(LegsMesh != none){ \n			LegsOcc.SetSkeletalMesh(LegsMesh); \n		} \n		else{ \n			LegsOcc.SetSkeletalMesh(Legs); \n		} \n	} \n \n	foreach InvManager.InventoryActors(class'Hat_CosmeticItem', CosmeticItem) \n	{ \n			if (CosmeticItem.isA('Hat_CosmeticItem_UpperBody')){ \n				CosmeticItem.OccludedMesh.DetachFromAny(); \n				AttachComponent(BodyOcc); \n			} \n			if (CosmeticItem.isA('Hat_CosmeticItem_Legs')){ \n				CosmeticItem.OccludedMesh.DetachFromAny(); \n				AttachComponent(LegsOcc); \n			} \n	} \n} \n defaultproperties \n{ \n	Begin Object Name=Mesh0 \n		SkeletalMesh=" + HeadText.Text + " \n		AnimSets(0)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Anims' \n		AnimSets(1)=AnimSet'HatInTime_Characters_HatKid.AnimSet.HatKidV2_Attack_Anims' \n		AnimSets(2)=AnimSet'HatInTime_Characters_HatKid2.AnimSet.HatKidV2_Cruise' \n \n		AnimTreeTemplate = AnimTree'HatInTime_Characters.AnimTree.PlatformPlayer_AnimTree' \n		PhysicsAsset=PhysicsAsset'HatinTime_Characters_CoPartner.Physics.CoPartner_Physics' \n		Translation=(Z=-36, Y=0, X=0) \n       		bNoSelfShadow=true \n	End Object \n \n \n \n	Begin Object Name=OccludedMesh0 \n		Materials(0)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(1)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(2)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(3)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(4)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(5)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(6)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(7)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(8)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(9)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(10)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(11)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(12)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(13)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(14)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(15)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(16)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(17)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		SkeletalMesh=" + HeadText.Text + " \n	End Object \n \n	Begin Object Class=SkeletalMeshComponent Name=OccludedMesh1 \n		Materials(0)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(1)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(2)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(3)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(4)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(5)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(6)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(7)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(8)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(9)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(10)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(11)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(12)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(13)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(14)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(15)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(16)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(17)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		SkeletalMesh=" + BodyText.Text + " \n		DepthPriorityGroup=SDPG_Foreground \n \n        ParentAnimComponent=Mesh0 \n		bUseBoundsFromParentAnimComponent = true \n \n		//General Mesh Properties \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=true \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=false \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bAcceptsDecals=true \n		bAcceptsDynamicDecals=true \n		HiddenEditor=true \n		bUseAsOccluder = false; \n		MotionBlurInstanceScale=0 \n	End Object \n	Components.add(OccludedMesh1) \n	BodyOcc = OccludedMesh1 \n \n	Begin Object Class=SkeletalMeshComponent Name=OccludedMesh2 \n		Materials(0)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(1)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(2)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(3)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(4)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(5)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(6)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(7)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(8)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(9)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(10)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(11)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(12)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(13)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(14)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(15)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(16)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		Materials(17)=Material'HatInTime_Characters.Materials.OccludedMaterial' \n		SkeletalMesh=" + LegsText.Text + " \n		DepthPriorityGroup=SDPG_Foreground \n \n        ParentAnimComponent=Mesh0 \n		bUseBoundsFromParentAnimComponent = true \n \n		bCacheAnimSequenceNodes=FALSE \n		AlwaysLoadOnClient=true \n		AlwaysLoadOnServer=true \n		bOwnerNoSee=false \n		CastShadow=false \n		BlockRigidBody=true \n		bUpdateSkelWhenNotRendered=true \n		bIgnoreControllersWhenNotRendered=false \n		bUpdateKinematicBonesFromAnimation=true \n		bCastDynamicShadow=false \n		RBChannel=RBCC_Untitled3 \n		RBCollideWithChannels=(Untitled3=true) \n		LightEnvironment=MyLightEnvironment \n		bOverrideAttachmentOwnerVisibility=true \n		TickGroup=TG_PreAsyncWork \n		RBDominanceGroup=20 \n		bUseOnePassLightingOnTranslucency=true \n		bAcceptsDecals=true \n		bAcceptsDynamicDecals=true \n		HiddenEditor=true \n		bUseAsOccluder = false; \n		MotionBlurInstanceScale=0 \n	End Object \n	Components.add(OccludedMesh2) \n	LegsOcc = OccludedMesh2 \n \n	Begin Object Class=" + BaseEXPText.Text + " Name=Expression1 \n	End Object \n	Components.Add(Expression1); \n	ExpressionComponent = Expression1; \n \n	Begin Object Name=StatueFall0 \n		StaticMesh=" + IceStatueText.Text + " \n		Translation=(Z=15, Y=0, X=0) \n	End Object \n \n \n \n	// properties \n	ObjectiveActorClass = class'" + PrefixText.Text + "_ObjectiveActor_" + PlayerNameText.Text + "' \n	CanWearHatKidCosmetics = true \n	MaterialIndexEyes = " + EyesText.Text + " \n    MaterialIndexFace = " + FaceText.Text + " \n	MaterialSectionPonytail = " + PonytailText.Text + " \n \n	Head = " + HeadText.Text + " \n	Body = " + BodyText.Text + " \n	Legs = " + LegsText.Text + " \n	FullModel = " + FullModelText.Text + " \n \n	RadHead = " + RadHeadText.Text + " \n	RadBody = " + RadBodyText.Text + " \n	RadLegs = " + RadLegsText.Text + " \n	RadFull = " + RadFullText.Text + " \n \n	PlushHead = " + PlushHeadText.Text + " \n	PlushBody = " + PlushBodyText.Text + " \n	PlushLegs = " + PlushLegsText.Text + " \n	PlushFull = " + PlushFullText.Text + " \n \n	WireHead = " + WireHeadText.Text + " \n	WireBody = " + WireBodyText.Text + " \n	WireLegs = " + WireLegsText.Text + " \n	WireFull = " + WireFullText.Text + " \n \n	VirtHead = " + VirtHeadText.Text + " \n	VirtBody = " + VirtBodyText.Text + " \n	VirtLegs = " + VirtLegsText.Text + " \n	VirtFull = " + VirtFullText.Text + " \n \n	FlatHead = " + DoodleText.Text + " \n	InvisMesh = " + InvisibleText.Text + " \n \n \n \n	SkinColor = (R=" + RText.Text + ",G=" + GText.Text + ",B=" + BText.Text + ") \n \n	PlayerVisualClass(0) = class'" + PrefixText.Text + "_Player_" + PlayerNameText.Text + "' \n} \n \nfunction DoSkinOverrides() \n{ \n	local class<Hat_Collectible_Skin> Skin; \n	local Hat_Loadout l; \n	local int i; \n \n \n	// get equipped skin \n	if (Controller == None) return; \n	l = Hat_PlayerController(Controller).GetLoadout(); \n	if (l != None && l.MyLoadout.Skin != None) \n		Skin = class<Hat_Collectible_Skin>(l.MyLoadout.Skin.BackpackClass); \n	if (Skin == None) \n		Skin = class'Hat_Collectible_Skin'; \n \n	if (Skin == class'Hat_Collectible_Skin_HatKid64') \n	{ \n		Skin.static.SetHeadMesh(self, VirtHead); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, VirtBody, Skin.default.SkinBodyPhysicsAsset); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, VirtLegs, Skin.default.SkinLegsPhysicsAsset); \n \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n	if (Skin == class'Hat_Collectible_Skin_Wireframe') \n	{ \n		Skin.static.SetHeadMesh(self, WireHead); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, WireBody, Skin.default.SkinBodyPhysicsAsset); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, WireLegs, Skin.default.SkinLegsPhysicsAsset); \n \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n		Skin.static.SetExpressionComponent(self, " + WireEXPText.Text + "); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n	if (Skin == class'Hat_Collectible_Skin_BodyMaterial_Shadow') \n	{ \n		Skin.static.SetExpressionComponent(self, " + ShadowEXPText.Text + "); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n	if (Skin == Radwave()) \n	{ \n		Skin.static.SetHeadMesh(self, RadHead); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, RadBody, Skin.default.SkinBodyPhysicsAsset); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, RadLegs, Skin.default.SkinLegsPhysicsAsset); \n \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n		Skin.static.SetExpressionComponent(self, " + RadEXPText.Text + "); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n	if (Skin == PlushKids()) \n	{ \n		Skin.static.SetHeadMesh(self, PlushHead); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, PlushBody, Skin.default.SkinBodyPhysicsAsset); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, PlushLegs, Skin.default.SkinLegsPhysicsAsset); \n \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n	if (Skin == FlatKid()) \n	{ \n		//Ya Know, I'm lazy \n		Skin.static.SetHeadMesh(self, FlatHead); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', self, InvisMesh, Skin.default.SkinBodyPhysicsAsset); \n		Skin.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', self, InvisMesh, Skin.default.SkinLegsPhysicsAsset); \n \n		for (i = 0; i < Mesh.GetNumElements(); i++) \n			Mesh.SetMaterial(i, None); \n		InitMaterialInstancesMesh(Mesh); \n \n		CleanFaceNextSkinUpdate = true; \n	} \n \n	FixTheOcclusion(Skin.default.SkinBodyMesh, Skin.default.SkinLegsMesh, Skin); \n} \n \n \nstatic function ConvertNPCPlayer(Hat_NPC_Player npc) \n{ \n	local Hat_ExpressionComponent exp; \n	local class<Hat_Collectible_Skin> CurrentSkin; \n	CurrentSkin = NPCGetCurrentSkin(npc); \n \n	if(CurrentSkin == RadWave()){ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.SkeletalMeshComponent.SetSkeletalMesh(default.RadHead); \n		npc.SkeletalMeshComponent.SetMaterial(0, None); \n		npc.SkeletalMeshComponent.SetMaterial(1, None); \n		npc.SkeletalMeshComponent.SetMaterial(2, None); \n		npc.SkeletalMeshComponent.SetMaterial(3, None); \n		npc.SkeletalMeshComponent.SetMaterial(4, None); \n		npc.SkeletalMeshComponent.SetMaterial(5, None); \n		npc.SkeletalMeshComponent.SetMaterial(6, None); \n		npc.SkeletalMeshComponent.SetMaterial(7, None); \n		exp = new " + RadEXPText.Text + "; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', npc, default.RadBody, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidBody_Physics'); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', npc, default.RadLegs, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidLegs_Physics'); \n \n	} \n	else if(CurrentSkin == class'Hat_Collectible_Skin_BodyMaterial_Shadow'){ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.SkeletalMeshComponent.SetMaterial(0, None); \n		npc.SkeletalMeshComponent.SetMaterial(1, None); \n		npc.SkeletalMeshComponent.SetMaterial(2, None); \n		npc.SkeletalMeshComponent.SetMaterial(3, None); \n		npc.SkeletalMeshComponent.SetMaterial(4, None); \n		npc.SkeletalMeshComponent.SetMaterial(5, None); \n		npc.SkeletalMeshComponent.SetMaterial(6, None); \n		npc.SkeletalMeshComponent.SetMaterial(7, None); \n		exp = new " + ShadowEXPText.Text + "; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n	} \n	else if(CurrentSkin == PlushKids()){ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.SkeletalMeshComponent.SetSkeletalMesh(default.PlushHead); \n		npc.SkeletalMeshComponent.SetMaterial(0, None); \n		npc.SkeletalMeshComponent.SetMaterial(1, None); \n		npc.SkeletalMeshComponent.SetMaterial(2, None); \n		npc.SkeletalMeshComponent.SetMaterial(3, None); \n		npc.SkeletalMeshComponent.SetMaterial(4, None); \n		npc.SkeletalMeshComponent.SetMaterial(5, None); \n		npc.SkeletalMeshComponent.SetMaterial(6, None); \n		npc.SkeletalMeshComponent.SetMaterial(7, None); \n		exp = none; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', npc, default.PlushBody, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidBody_Physics'); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', npc, default.PlushLegs, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidLegs_Physics'); \n \n	} \n	else if(CurrentSkin == class'Hat_Collectible_Skin_Wireframe'){ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.SkeletalMeshComponent.SetSkeletalMesh(default.WireHead); \n		npc.SkeletalMeshComponent.SetMaterial(0, None); \n		npc.SkeletalMeshComponent.SetMaterial(1, None); \n		npc.SkeletalMeshComponent.SetMaterial(2, None); \n		npc.SkeletalMeshComponent.SetMaterial(3, None); \n		npc.SkeletalMeshComponent.SetMaterial(4, None); \n		exp = new " + WireEXPText.Text + "; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n		npc.InitMaterialInstancesMesh(npc.SkeletalMeshComponent); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', npc, default.WireBody, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidBody_Physics'); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', npc, default.WireLegs, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidLegs_Physics'); \n \n	} \n	else if(CurrentSkin == class'Hat_Collectible_Skin_HatKid64'){ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.SkeletalMeshComponent.SetSkeletalMesh(default.VirtHead); \n		npc.SkeletalMeshComponent.SetMaterial(0, None); \n		npc.SkeletalMeshComponent.SetMaterial(1, None); \n		npc.SkeletalMeshComponent.SetMaterial(2, None); \n		npc.SkeletalMeshComponent.SetMaterial(3, None); \n		npc.SkeletalMeshComponent.SetMaterial(4, None); \n		npc.SkeletalMeshComponent.SetMaterial(5, None); \n		npc.SkeletalMeshComponent.SetMaterial(6, None); \n		npc.SkeletalMeshComponent.SetMaterial(7, None); \n		exp = none; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidUpperBody', npc, default.VirtBody, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidBody_Physics'); \n		class'Hat_Collectible_Skin'.static.ApplyMeshSkin(class'Hat_CosmeticItem_HatKidLegs', npc, default.VirtLegs, PhysicsAsset'HatInTime_Characters_HatKid.Physics.HatKidLegs_Physics'); \n \n	} \n	else{ \n		npc.DisableHats = false; \n		npc.DisableMasks = false; \n		npc.DisableUpperBody = false; \n		npc.DisableLegs = false; \n		npc.AddDefaultInventory(); \n		InitAllMaterials(npc); \n		ApplySkin(npc, NPCGetCurrentSkin(npc)); \n		InitAllMaterials(npc); \n		//Replace these with your player materials \n \n		exp = new " + BaseEXPText.Text + "; \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression = exp; \n		npc.Expression.Init(npc); \n		InitAllMaterials(npc); \n \n		UpdateColorsTextures(npc, CurrentSkin); \n		npc.DetachComponent(npc.Expression); \n		npc.AttachComponent(exp); \n		npc.Expression.Init(npc); \n	} \n \n}");
				}
			}

			pathString = System.IO.Path.Combine(path, "Output");
			fileName = PrefixText.Text + "_ObjectiveActor_" + PlayerNameText.Text + ".uc";
			pathString = System.IO.Path.Combine(pathString, fileName);

			if (!System.IO.File.Exists(pathString))
			{
				using (StreamWriter writer = new StreamWriter(pathString))
				{
					writer.WriteLine("class " + PrefixText.Text + "_ObjectiveActor_" + PlayerNameText.Text + " extends Hat_ObjectiveActor_HatKid;\n\ndefaultproperties\n{\n\tHUDIcon = " + PlayerIconText.Text + "; \n}");
				}
			}
		}

		private void Output_Click(object sender, EventArgs e)
		{
			string path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop); //It's a step in the right direction however not what I'm looking for specifically
			string pathString = System.IO.Path.Combine(path, "Output");
			System.IO.Directory.CreateDirectory(pathString);
			Process.Start(pathString);
		}

		private void Form1_Load(object sender, EventArgs e)
		{

		}

        private void checkBox1_CheckedChanged(object sender, EventArgs e)
        {
            if (checkBox1.Checked)
            {
                TestBox.Show();
                textBox1.Show();
            }
            else {
                TestBox.Hide();
                textBox1.Hide();
            }
        }

        private void fileSystemWatcher1_Changed(object sender, FileSystemEventArgs e)
        {

        }
    }
}
